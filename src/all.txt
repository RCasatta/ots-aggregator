extern crate hyper;
extern crate futures;
extern crate tokio;

use hyper::header::ContentLength;
use hyper::server::{Http, Request, Response, Service};
use futures::{Future, Stream, Async, Poll, future};
use futures::future::FutureResult;
use tokio::executor::current_thread;
use std::sync::mpsc;
//use std::sync::mpsc::Sender;
use hyper::Body;
//use std::sync::mpsc::Receiver;
use std::sync::Arc;
use std::sync::RwLock;
use futures::sync::oneshot::Receiver;


use futures::future::result;
const PHRASE: &'static str = "Hello, World!";

struct HelloWorld {
    tx: Sender<SendBack>,
}

struct SendBack {
    a: String,
    result: Sender<FutureResult<Response<Body>, hyper::Error>>,
}

use std::time::Instant;
use std::{thread, time};
use futures::prelude::*;

struct MerkleBuilder {
    leaves : Vec<i32>,
}

impl MerkleBuilder {
    fn new() -> MerkleBuilder {
        MerkleBuilder {
            leaves: vec!(),
        }
    }

    fn add_digest(&mut self, leaf : i32) {
        self.leaves.push(leaf);
    }

    fn get_future() {

    }
}


pub struct FutureSender {
    rx : Receiver<u32>,
}
impl FutureSender {
    fn new(rx : Receiver<u32>) -> FutureSender {
        FutureSender {
            rx
        }
    }
}

impl Future for FutureSender {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {

        match self.inner.poll()? {
            Async::Ready(v) => {
                println!("{:?}",v);
                Ok(Async::Ready(()))
            },
            Async::NotReady => Ok(Async::NotReady),
        }
    }
}


pub struct FutureReceiver {
    inner: Arc<RwLock<FutureSender>>,
}

impl FutureReceiver {
    fn new(inner : Arc<RwLock<FutureSender>>) -> FutureReceiver {
        FutureReceiver {
           inner,
        }
    }
}

impl Future for FutureReceiver {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Result<Async<()>, ()> {



        match self.inner.write().unwrap().poll()? {

            Async::Ready(v) => {
                println!("ok {:?}", v );
                Ok(Async::Ready(()))
            },
            Async::NotReady => {
                println!("err");
                Ok(Async::NotReady)
            },
        }
    }
}


fn main() {

    let (tx,rx) = futures::oneshot();

    let future_sender = FutureSender::new(rx);
    let arc_future = Arc::new(RwLock::new(future_sender));
    let observer = FutureReceiver::new(arc_future.clone());
    let observer_2 = FutureReceiver::new(arc_future.clone());

    let _ = thread::spawn(move || {
        thread::sleep(time::Duration::from_secs(1));
        println!("set");
        tx.send(10);
    });

    /*
    current_thread::run(|_| {

        // Now, the server task is spawned.
        current_thread::spawn(observer);
    });

*/


        let value = observer.wait().unwrap();
        println!("2");
        println!("{:?}",value);

    /*
    let addr = "127.0.0.1:3000".parse().unwrap();
    let (tx  ,rx) =   mpsc::channel();

    let server = Http::new().bind(&addr, move || Ok(HelloWorld {
        tx : tx.clone(),
    })).unwrap();

    let _ = thread::spawn(move || {
        let mut i=0;
        let mut vec = vec!();

        loop {
            let value = rx.recv().unwrap();
            i = i+1;
            vec.push(i);
            let future = futures::future::ok(
                Response::new()
                    .with_header(ContentLength(PHRASE.len() as u64))
                    .with_body(format!("{}{}",i,PHRASE) )
            );
            //let future = Doubler{ inner: future };
            value.result.send(future);
        }
    });

    server.run().unwrap();*/

    /*let future = future::ok::<u32, u32>(1);
    let future_of_1 = result::<u32, u32>(Ok(1));
    let doubler = double(future_of_1);
    println!("{:?}",doubler);
    println!("{:?}",doubler.wait());
*/
    /*let future_1 = future::ok::<u32, ()>(1);

    let future_2 = future_1.and_then(|x| {
        let one_sec = time::Duration::from_millis(5000);
        thread::sleep(one_sec);
        println!("2 {:?} {}", Instant::now(), x);
        Ok(1+x)
    });
    let task = future_2.and_then(|x| {
        let one_sec = time::Duration::from_millis(5000);
        thread::sleep(one_sec);
        println!("task {:?} {}", Instant::now(), x);
        Ok(())
    });

    current_thread::run(|_| {
        // Now, the server task is spawned.
        current_thread::spawn(task);

    });*/

/*
    let future = future::ok::<u32, u32>(1);
    let new_future = future.map(|x| x + 3);
    let new_future_2 = &new_future;
    assert_eq!(new_future.wait(), Ok(4));
    assert_eq!(new_future_2.wait(), Ok(4));

    let future1 = future::lazy(|| {
        thread::sleep(time::Duration::from_secs(15));
        future::ok::<char, ()>('a')
    });

    let future2 = future::lazy(|| {
        thread::sleep(time::Duration::from_secs(13));
        future::ok::<char, ()>('b')
    });

    let (value, last_future) = future1.select(future2).wait().ok().unwrap();
    assert_eq!(value, 'a');
    assert_eq!(last_future.wait().unwrap(), 'b');
*/
}

#[derive(Debug)]
pub struct Doubler<T> {
    inner: T,
}

pub fn double<T>(inner: T) -> Doubler<T> {
    Doubler { inner }
}

impl<T> Future for Doubler<T>
    where T: Future<Item = usize>
{
    type Item = usize;
    type Error = T::Error;

    fn poll(&mut self) -> Result<Async<usize>, T::Error> {
        match self.inner.poll()? {
            Async::Ready(v) => Ok(Async::Ready(v * 2)),
            Async::NotReady => Ok(Async::NotReady),
        }
    }
}

impl Service for HelloWorld {
    // boilerplate hooking up hyper's server types
    type Request = Request;
    type Response = Response;
    type Error = hyper::Error;
    // The future representing the eventual Response your call will
    // resolve to. This can change to whatever Future you need.
    type Future = Box<Future<Item=Self::Response, Error=Self::Error>>;

    fn call(&self, _req: Request) -> Self::Future {

        let (result_tx,result_rx) =   mpsc::channel();
        self.tx.send(SendBack{ a:"client_digest".to_owned(), result:  result_tx}).unwrap();
        let result = result_rx.recv().unwrap();
        //println!("{:?}", result);

        Box::new(result)
    }
}

enum State {
    Aggregating,
    MerkleClosedAndAsked,
    Resolved,
}

pub struct Aggregate {
    state: State,
}

impl Future for Aggregate {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        unimplemented!()
    }
}